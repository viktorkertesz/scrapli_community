<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>scrapli_community.features.asyncscp API documentation</title>
<meta name="description" content="scrapli_community.features.asyncscp" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scrapli_community.features.asyncscp</code></h1>
</header>
<section id="section-intro">
<p>scrapli_community.features.asyncscp</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;scrapli_community.features.asyncscp&#34;&#34;&#34;
from scrapli_community.features.asyncscp.driver import AsyncSCPFeature, FileCheckResult

__all__ = (&#34;AsyncSCPFeature&#34;, &#34;FileCheckResult&#34;)</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="scrapli_community.features.asyncscp.driver" href="driver.html">scrapli_community.features.asyncscp.driver</a></code></dt>
<dd>
<div class="desc"><p>scrapli_community.features.asyncscp.extension</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scrapli_community.features.asyncscp.AsyncSCPFeature"><code class="flex name class">
<span>class <span class="ident">AsyncSCPFeature</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This class extends a driver with SCP capabilities</p>
<p>You need to implement device specific methods. If your device does not support that method,
just return a value described in the abstract methods.</p>
<p>BaseDriver Object</p>
<p>BaseDriver is the root for all Scrapli driver classes. The synchronous and asyncio driver
base driver classes can be used to provide a semi-pexpect like experience over top of
whatever transport a user prefers. Generally, however, the base driver classes should not be
used directly. It is best to use the GenericDriver (or AsyncGenericDriver) or NetworkDriver
(or AsyncNetworkDriver) sub-classes of the base drivers.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>host</code></strong></dt>
<dd>host ip/name to connect to</dd>
<dt><strong><code>port</code></strong></dt>
<dd>port to connect to</dd>
<dt><strong><code>auth_username</code></strong></dt>
<dd>username for authentication</dd>
<dt><strong><code>auth_private_key</code></strong></dt>
<dd>path to private key for authentication</dd>
<dt><strong><code>auth_private_key_passphrase</code></strong></dt>
<dd>passphrase for decrypting ssh key if necessary</dd>
<dt><strong><code>auth_password</code></strong></dt>
<dd>password for authentication</dd>
<dt><strong><code>auth_strict_key</code></strong></dt>
<dd>strict host checking or not</dd>
<dt><strong><code>auth_bypass</code></strong></dt>
<dd>bypass "in channel" authentication &ndash; only supported with telnet,
asynctelnet, and system transport plugins</dd>
<dt><strong><code>timeout_socket</code></strong></dt>
<dd>timeout for establishing socket/initial connection in seconds</dd>
<dt><strong><code>timeout_transport</code></strong></dt>
<dd>timeout for ssh|telnet transport in seconds</dd>
<dt><strong><code>timeout_ops</code></strong></dt>
<dd>timeout for ssh channel operations</dd>
<dt><strong><code>comms_prompt_pattern</code></strong></dt>
<dd>raw string regex pattern &ndash; preferably use <code>^</code> and <code>$</code> anchors!
this is the single most important attribute here! if this does not match a prompt,
scrapli will not work!
IMPORTANT: regex search uses multi-line + case insensitive flags. multi-line allows
for highly reliably matching for prompts however we do NOT strip trailing whitespace
for each line, so be sure to add '\s?' or similar if your device needs that. This
should be mostly sorted for you if using network drivers (i.e. <code>IOSXEDriver</code>).
Lastly, the case insensitive is just a convenience factor so i can be lazy.</dd>
<dt><strong><code>comms_return_char</code></strong></dt>
<dd>character to use to send returns to host</dd>
<dt><strong><code>ssh_config_file</code></strong></dt>
<dd>string to path for ssh config file, True to use default ssh config file
or False to ignore default ssh config file</dd>
<dt><strong><code>ssh_known_hosts_file</code></strong></dt>
<dd>string to path for ssh known hosts file, True to use default known
file locations. Only applicable/needed if <code>auth_strict_key</code> is set to True</dd>
<dt><strong><code>on_init</code></strong></dt>
<dd>callable that accepts the class instance as its only argument. this callable,
if provided, is executed as the last step of object instantiation &ndash; its purpose is
primarily to provide a mechanism for scrapli community platforms to have an easy way
to modify initialization arguments/object attributes without needing to create a
class that extends the driver, instead allowing the community platforms to simply
build from the GenericDriver or NetworkDriver classes, and pass this callable to do
things such as appending to a username (looking at you RouterOS!!). Note that this
is <em>always</em> a synchronous function (even for asyncio drivers)!</dd>
<dt><strong><code>on_open</code></strong></dt>
<dd>callable that accepts the class instance as its only argument. this callable,
if provided, is executed immediately after authentication is completed. Common use
cases for this callable would be to disable paging or accept any kind of banner
message that prompts a user upon connection</dd>
<dt><strong><code>on_close</code></strong></dt>
<dd>callable that accepts the class instance as its only argument. this callable,
if provided, is executed immediately prior to closing the underlying transport.
Common use cases for this callable would be to save configurations prior to exiting,
or to logout properly to free up vtys or similar</dd>
<dt><strong><code>transport</code></strong></dt>
<dd>name of the transport plugin to use for the actual telnet/ssh/netconf
connection. Available "core" transports are:
- system
- telnet
- asynctelnet
- ssh2
- paramiko
- asyncssh
Please see relevant transport plugin section for details. Additionally third party
transport plugins may be available.</dd>
<dt><strong><code>transport_options</code></strong></dt>
<dd>dictionary of options to pass to selected transport class; see
docs for given transport class for details of what to pass here</dd>
<dt><strong><code>channel_lock</code></strong></dt>
<dd>True/False to lock the channel (threading.Lock/asyncio.Lock) during
any channel operations, defaults to False</dd>
<dt><strong><code>channel_log</code></strong></dt>
<dd>True/False or a string path to a file of where to write out channel logs &ndash;
these are not "logs" in the normal logging module sense, but only the output that is
read from the channel. In other words, the output of the channel log should look
similar to what you would see as a human connecting to a device</dd>
<dt><strong><code>channel_log_mode</code></strong></dt>
<dd>"write"|"append", all other values will raise ValueError,
does what it sounds like it should by setting the channel log to the provided mode</dd>
<dt><strong><code>logging_uid</code></strong></dt>
<dd>unique identifier (string) to associate to log messages; useful if you have
multiple connections to the same device (i.e. one console, one ssh, or one to each
supervisor module, etc.)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AsyncSCPFeature(BaseDriver, ABC):
    &#34;&#34;&#34;
    This class extends a driver with SCP capabilities

    You need to implement device specific methods. If your device does not support that method,
    just return a value described in the abstract methods.
    &#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        # \x0C is CTRL-L which usually refresh the prompt and harmless to send as keepalive
        self.keepalive_pattern = &#34;\x0C&#34;.encode(&#34;UTF-8&#34;)
        super().__init__(*args, **kwargs)

    @abstractmethod
    async def check_device_file(self, device_fs: Optional[str], file_name: str) -&gt; FileCheckResult:
        &#34;&#34;&#34;
        Check remote file and storage space
        Returning empty hash means error accessing the file

        Args:
            device_fs: filesystem on device (e.g. disk0:/)
            file_name: file to examine

        Returns:
            FileCheckResult
        &#34;&#34;&#34;
        ...

    @abstractmethod
    async def _ensure_scp_capability(self, force: Optional[bool] = False) -&gt; Union[bool, None]:
        &#34;&#34;&#34;
        Ensure device is capable of using scp.

        Args:
            force: Try reconfigure device if it doesn&#39;t support scp. If set to `None`, don&#39;t check
                   anything.

        Returns:
            bool: `True` if device supports scp now and we changed configuration.
                  `False` if device does not support scp or we didn&#39;t force configuration which was
                          needed.
                  `None` if we are good to proceed or we didn&#39;t check at all.
        &#34;&#34;&#34;
        ...

    @abstractmethod
    async def _cleanup_after_transfer(self) -&gt; None:
        &#34;&#34;&#34;
        Device specific cleanup procedure if needed. Useful to restore configuration in case
        _ensure_scp_capability reconfigured the device.

        Returns:
            None
        &#34;&#34;&#34;
        ...

    @abstractmethod
    async def _get_device_fs(self) -&gt; Optional[str]:
        &#34;&#34;&#34;
        Device specific drive detection.

        Returns:
            Drive as a string. E.g. disk0:/ or flash0:/
            `None`, if drive not detected or detection is not supported
        &#34;&#34;&#34;
        ...

    async def check_local_file(self, device_fs: Optional[str], file_name: str) -&gt; FileCheckResult:
        &#34;&#34;&#34;
        Check local file and storage space

        Args:
            device_fs: If specified, this path will be checked for free space. Else path will be
                       taken from `file_name`
            file_name: local file to examine. This should be the full path of local file

        Returns:
            FileCheckResult
        &#34;&#34;&#34;
        try:
            async with aiofiles.open(file_name, &#34;rb&#34;) as f:
                file_hash = hashlib.md5(await f.read()).hexdigest()
                self.logger.info(f&#34;&#39;{file_name}&#39; hash is &#39;{file_hash}&#39;&#34;)
            file_size = os.path.getsize(file_name)
        except FileNotFoundError:
            file_size = 0
            file_hash = &#34;&#34;
        try:
            path = device_fs if device_fs else os.path.dirname(file_name)
            # check free space of directory of the file or the local dir
            free_space = shutil.disk_usage(path if path else &#34;.&#34;).free
        except FileNotFoundError:
            free_space = 0
        return FileCheckResult(hash=file_hash, size=file_size, free=free_space)

    async def _async_file_transfer(  # noqa: C901
        self,
        operation: Literal[&#34;get&#34;, &#34;put&#34;],
        src: str,
        dst: str,
        progress_handler: Optional[Callable] = None,
        prevent_timeout: Optional[float] = None,
    ) -&gt; bool:
        &#34;&#34;&#34;
        SCP a file from device to localhost

        Args:
            operation: &#39;get&#39; or &#39;put&#39; files from or to the device
            src: Source file name
            dst: Destination file name
            progress_handler: scp callback function to be able to follow the copy progress
            prevent_timeout: interval in seconds when we send an empty command to keep SSH channel
                             up, 0 to turn it off,
                             default is same as `timeout_ops`

        Returns:
            bool: True on success
        &#34;&#34;&#34;

        start_time = 0.0
        if prevent_timeout is None:
            prevent_timeout = self.timeout_ops

        async def _prevent_timeout():
            &#34;&#34;&#34;Send enter to idle SSH channel to prevent timing out while transferring file&#34;&#34;&#34;
            self.logger.info(&#34;Sending keepalive to device&#34;)
            self.transport.write(self.keepalive_pattern)

        def timed_progress_handler(srcpath, dstpath, copied, total):
            &#34;&#34;&#34;Progress handler wrapper which prevents timeouts while file transfer&#34;&#34;&#34;
            nonlocal start_time

            now = time()
            if 0 &lt; prevent_timeout &lt;= (now - start_time):
                self.logger.debug(&#34;Preventing timeout&#34;)
                asyncio.ensure_future(_prevent_timeout())
                start_time = now

            # call original handler if specified
            if progress_handler:
                progress_handler(srcpath, dstpath, copied, total)

        # noinspection PyProtectedMember
        scp_options = SCPConnectionParameterType(
            username=self.auth_username,
            password=self.auth_password,
            port=self.port,
            host=self.host,
            options=self.transport.session._options,  # noqa: W0212
        )
        result = False
        try:
            async with connect(**scp_options) as scp_conn:
                start_time = time()
                if operation == &#34;get&#34;:
                    await scp(
                        (scp_conn, src),
                        dst,
                        progress_handler=timed_progress_handler,
                        block_size=65536,
                    )
                elif operation == &#34;put&#34;:
                    await scp(
                        src,
                        (scp_conn, dst),
                        progress_handler=timed_progress_handler,
                        block_size=65536,
                    )
                else:
                    raise ValueError(f&#34;Invalid operation: {operation}&#34;)
        except (asyncssh.SFTPError,) as e:
            result = False
            self.logger.warning(f&#34;SCP error: {e}&#34;)
        except Exception as e:
            result = False
            self.logger.warning(f&#34;Other error: {e}&#34;)
            raise e
        else:
            result = True

        return result

    async def file_transfer(  # noqa: C901
        self,
        operation: Literal[&#34;get&#34;, &#34;put&#34;],
        src: str,
        dst: str,
        verify: bool = True,
        device_fs: Optional[str] = None,
        overwrite: bool = False,
        force_scp_config: bool = False,
        cleanup: bool = True,
        progress_handler: Optional[Callable] = None,
        prevent_timeout: Optional[float] = None,
    ) -&gt; FileTransferResult:
        &#34;&#34;&#34;
        Cisco IOS XE file transfer
        This transfer is idempotent and does the following checks before/after transfer:
        1. checksum
        2. existence of file at destination (also with hash)
        3. available space at destination
        4. scp enablement on device (and tries to turn it on if needed)
        5. restore configuration after transfer if it was changed
        6. check MD5 after transfer

        The file won&#39;t be transferred if the hash of the files on local/device are the same!

        Args:
            operation: put/get file to/from device
            src: source file name
            dst: destination file name
            verify: `True` if verification is needed (checksum, file existence, disk space)
            device_fs: IOS device filesystem (autodetect if empty)
            overwrite: If set to `True`, destination will be overwritten in case hash verification
                       fails
                       If set to `False`, destination file won&#39;t be overwritten.
                       Beware: turning off `verify` will make this parameter ignored and destination
                        will be overwritten regardless! (Logic is that if user does not care about
                        checking, just copy it over)
            force_scp_config: If set to `True`, SCP function will be enabled in device configuration
                               before transfer.
                              If set to `False`, SCP functionality will be checked but won&#39;t
                              configure the device.
                              If set to `None`, capability won&#39;t even checked.
            cleanup: If set to True, call the cleanup procedure to restore configuration if it was
                     altered
            progress_handler: function to call by file copy (used by asyncssh.scp function)
            prevent_timeout: interval in seconds when we send an empty command to keep SSH channel
                             up, 0 to turn it off, default is same as `timeout_ops`

        Returns:
            FileTransferResult
        &#34;&#34;&#34;

        result = FileTransferResult(False, False, False)
        src_file_data = FileCheckResult(&#34;&#34;, 0, 0)
        dst_file_data = FileCheckResult(&#34;&#34;, 0, 0)
        if prevent_timeout is None:
            prevent_timeout = self.timeout_ops
        dst_device_fs: Optional[str] = None
        src_device_fs: Optional[str] = None

        # set destination filename to source if missing
        if dst in (&#34;&#34;, &#34;.&#34;):
            # set destination to filename and strip all path
            dst = PurePath(src).name

        # Detect default filesystem the device use
        if not device_fs:
            device_fs = await self._get_device_fs()

        if operation == &#34;get&#34;:
            src_check = self.check_device_file
            src_device_fs = device_fs
            dst_check = self.check_local_file
        elif operation == &#34;put&#34;:
            src_check = self.check_local_file
            dst_check = self.check_device_file
            dst_device_fs = device_fs
        else:
            raise ValueError(f&#34;Operation &#39;{operation}&#39; is not supported&#34;)

        if verify:
            # gather info on source side
            src_file_data = await src_check(src_device_fs, src)
            self.logger.debug(f&#34;Source file &#39;{src}&#39;: {src_file_data}&#34;)
            if not src_file_data.hash:
                # source file cannot be found, we are done here
                self.logger.warning(f&#34;Source file &#39;{src}&#39; does NOT exists!&#34;)
                return result
            # gather info on destination file
            dst_file_data = await dst_check(dst_device_fs, dst)
            self.logger.debug(f&#34;Destination file &#39;{dst}&#39;: {dst_file_data}&#34;)
            # check if destination file exists
            if dst_file_data.hash:
                result.exists = True
            # check if destination file has the same hash as source
            if dst_file_data.hash and src_file_data.hash == dst_file_data.hash:
                result.verified = True
                # no need to transfer file
                self.logger.info(f&#34;&#39;{dst}&#39; file already exists at destination and verified OK&#34;)
                return result

            # if hash does not match and we want to overwrite
            if dst_file_data.hash and not overwrite:
                self.logger.warning(f&#34;&#39;{dst}&#39; file will NOT be overwritten!&#34;)
                return result

            # check if we have enough free space to transfer the file
            if dst_file_data.free &lt; src_file_data.size:
                self.logger.warning(
                    f&#34;&#39;{dst}&#39; file is too big ({src_file_data.size}). Destination free space: &#34;
                    f&#34;{dst_file_data.free}&#34;
                )
                return result

        # check if we are capable of transferring files
        scp_capability = await self._ensure_scp_capability(force=force_scp_config)
        if scp_capability is False:
            self.logger.error(&#34;SCP feature is not enabled on device!&#34;)
            return result

        _need_to_cleanup = scp_capability

        # transfer the file
        try:
            _transferred = await self._async_file_transfer(
                operation,
                src,
                dst,
                progress_handler=progress_handler,
                prevent_timeout=prevent_timeout,
            )
            result.transferred = _transferred
        except Exception as e:
            raise e

        # clean up if needed
        if cleanup and _need_to_cleanup:
            await self._cleanup_after_transfer()

        if verify:
            # check destination file after copy
            dst_file_data = await dst_check(dst_device_fs, dst)
            # check if file was created
            if dst_file_data.hash:
                result.exists = True
            # check if file has the same hash as source
            if dst_file_data.hash and dst_file_data.hash == src_file_data.hash:
                result.verified = True
            else:
                self.logger.warning(f&#34;&#39;{dst}&#39; failed hash verification!&#34;)
        else:
            # assuming transfer created the file even if we did not check hash
            if result.transferred:
                result.exists = True
        return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scrapli.driver.base.base_driver.BaseDriver</li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scrapli_community.cisco.cisco_iosxe.async_driver.AsyncCommunityIOSXEDriver" href="../../cisco/cisco_iosxe/async_driver.html#scrapli_community.cisco.cisco_iosxe.async_driver.AsyncCommunityIOSXEDriver">AsyncCommunityIOSXEDriver</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrapli_community.features.asyncscp.AsyncSCPFeature.check_device_file"><code class="name flex">
<span>async def <span class="ident">check_device_file</span></span>(<span>self, device_fs: Union[str, NoneType], file_name: str) ‑> <a title="scrapli_community.features.asyncscp.driver.FileCheckResult" href="driver.html#scrapli_community.features.asyncscp.driver.FileCheckResult">FileCheckResult</a></span>
</code></dt>
<dd>
<div class="desc"><p>Check remote file and storage space
Returning empty hash means error accessing the file</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>device_fs</code></strong></dt>
<dd>filesystem on device (e.g. disk0:/)</dd>
<dt><strong><code>file_name</code></strong></dt>
<dd>file to examine</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>FileCheckResult</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
async def check_device_file(self, device_fs: Optional[str], file_name: str) -&gt; FileCheckResult:
    &#34;&#34;&#34;
    Check remote file and storage space
    Returning empty hash means error accessing the file

    Args:
        device_fs: filesystem on device (e.g. disk0:/)
        file_name: file to examine

    Returns:
        FileCheckResult
    &#34;&#34;&#34;
    ...</code></pre>
</details>
</dd>
<dt id="scrapli_community.features.asyncscp.AsyncSCPFeature.check_local_file"><code class="name flex">
<span>async def <span class="ident">check_local_file</span></span>(<span>self, device_fs: Union[str, NoneType], file_name: str) ‑> <a title="scrapli_community.features.asyncscp.driver.FileCheckResult" href="driver.html#scrapli_community.features.asyncscp.driver.FileCheckResult">FileCheckResult</a></span>
</code></dt>
<dd>
<div class="desc"><p>Check local file and storage space</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>device_fs</code></strong></dt>
<dd>If specified, this path will be checked for free space. Else path will be
taken from <code>file_name</code></dd>
<dt><strong><code>file_name</code></strong></dt>
<dd>local file to examine. This should be the full path of local file</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>FileCheckResult</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def check_local_file(self, device_fs: Optional[str], file_name: str) -&gt; FileCheckResult:
    &#34;&#34;&#34;
    Check local file and storage space

    Args:
        device_fs: If specified, this path will be checked for free space. Else path will be
                   taken from `file_name`
        file_name: local file to examine. This should be the full path of local file

    Returns:
        FileCheckResult
    &#34;&#34;&#34;
    try:
        async with aiofiles.open(file_name, &#34;rb&#34;) as f:
            file_hash = hashlib.md5(await f.read()).hexdigest()
            self.logger.info(f&#34;&#39;{file_name}&#39; hash is &#39;{file_hash}&#39;&#34;)
        file_size = os.path.getsize(file_name)
    except FileNotFoundError:
        file_size = 0
        file_hash = &#34;&#34;
    try:
        path = device_fs if device_fs else os.path.dirname(file_name)
        # check free space of directory of the file or the local dir
        free_space = shutil.disk_usage(path if path else &#34;.&#34;).free
    except FileNotFoundError:
        free_space = 0
    return FileCheckResult(hash=file_hash, size=file_size, free=free_space)</code></pre>
</details>
</dd>
<dt id="scrapli_community.features.asyncscp.AsyncSCPFeature.file_transfer"><code class="name flex">
<span>async def <span class="ident">file_transfer</span></span>(<span>self, operation: Literal['get', 'put'], src: str, dst: str, verify: bool = True, device_fs: Union[str, NoneType] = None, overwrite: bool = False, force_scp_config: bool = False, cleanup: bool = True, progress_handler: Union[Callable, NoneType] = None, prevent_timeout: Union[float, NoneType] = None) ‑> <a title="scrapli_community.features.asyncscp.driver.FileTransferResult" href="driver.html#scrapli_community.features.asyncscp.driver.FileTransferResult">FileTransferResult</a></span>
</code></dt>
<dd>
<div class="desc"><p>Cisco IOS XE file transfer
This transfer is idempotent and does the following checks before/after transfer:
1. checksum
2. existence of file at destination (also with hash)
3. available space at destination
4. scp enablement on device (and tries to turn it on if needed)
5. restore configuration after transfer if it was changed
6. check MD5 after transfer</p>
<p>The file won't be transferred if the hash of the files on local/device are the same!</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>operation</code></strong></dt>
<dd>put/get file to/from device</dd>
<dt><strong><code>src</code></strong></dt>
<dd>source file name</dd>
<dt><strong><code>dst</code></strong></dt>
<dd>destination file name</dd>
<dt><strong><code>verify</code></strong></dt>
<dd><code>True</code> if verification is needed (checksum, file existence, disk space)</dd>
<dt><strong><code>device_fs</code></strong></dt>
<dd>IOS device filesystem (autodetect if empty)</dd>
<dt><strong><code>overwrite</code></strong></dt>
<dd>If set to <code>True</code>, destination will be overwritten in case hash verification
fails
If set to <code>False</code>, destination file won't be overwritten.
Beware: turning off <code>verify</code> will make this parameter ignored and destination
will be overwritten regardless! (Logic is that if user does not care about
checking, just copy it over)</dd>
<dt><strong><code>force_scp_config</code></strong></dt>
<dd>If set to <code>True</code>, SCP function will be enabled in device configuration
before transfer.
If set to <code>False</code>, SCP functionality will be checked but won't
configure the device.
If set to <code>None</code>, capability won't even checked.</dd>
<dt><strong><code>cleanup</code></strong></dt>
<dd>If set to True, call the cleanup procedure to restore configuration if it was
altered</dd>
<dt><strong><code>progress_handler</code></strong></dt>
<dd>function to call by file copy (used by asyncssh.scp function)</dd>
<dt><strong><code>prevent_timeout</code></strong></dt>
<dd>interval in seconds when we send an empty command to keep SSH channel
up, 0 to turn it off, default is same as <code>timeout_ops</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<p>FileTransferResult</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def file_transfer(  # noqa: C901
    self,
    operation: Literal[&#34;get&#34;, &#34;put&#34;],
    src: str,
    dst: str,
    verify: bool = True,
    device_fs: Optional[str] = None,
    overwrite: bool = False,
    force_scp_config: bool = False,
    cleanup: bool = True,
    progress_handler: Optional[Callable] = None,
    prevent_timeout: Optional[float] = None,
) -&gt; FileTransferResult:
    &#34;&#34;&#34;
    Cisco IOS XE file transfer
    This transfer is idempotent and does the following checks before/after transfer:
    1. checksum
    2. existence of file at destination (also with hash)
    3. available space at destination
    4. scp enablement on device (and tries to turn it on if needed)
    5. restore configuration after transfer if it was changed
    6. check MD5 after transfer

    The file won&#39;t be transferred if the hash of the files on local/device are the same!

    Args:
        operation: put/get file to/from device
        src: source file name
        dst: destination file name
        verify: `True` if verification is needed (checksum, file existence, disk space)
        device_fs: IOS device filesystem (autodetect if empty)
        overwrite: If set to `True`, destination will be overwritten in case hash verification
                   fails
                   If set to `False`, destination file won&#39;t be overwritten.
                   Beware: turning off `verify` will make this parameter ignored and destination
                    will be overwritten regardless! (Logic is that if user does not care about
                    checking, just copy it over)
        force_scp_config: If set to `True`, SCP function will be enabled in device configuration
                           before transfer.
                          If set to `False`, SCP functionality will be checked but won&#39;t
                          configure the device.
                          If set to `None`, capability won&#39;t even checked.
        cleanup: If set to True, call the cleanup procedure to restore configuration if it was
                 altered
        progress_handler: function to call by file copy (used by asyncssh.scp function)
        prevent_timeout: interval in seconds when we send an empty command to keep SSH channel
                         up, 0 to turn it off, default is same as `timeout_ops`

    Returns:
        FileTransferResult
    &#34;&#34;&#34;

    result = FileTransferResult(False, False, False)
    src_file_data = FileCheckResult(&#34;&#34;, 0, 0)
    dst_file_data = FileCheckResult(&#34;&#34;, 0, 0)
    if prevent_timeout is None:
        prevent_timeout = self.timeout_ops
    dst_device_fs: Optional[str] = None
    src_device_fs: Optional[str] = None

    # set destination filename to source if missing
    if dst in (&#34;&#34;, &#34;.&#34;):
        # set destination to filename and strip all path
        dst = PurePath(src).name

    # Detect default filesystem the device use
    if not device_fs:
        device_fs = await self._get_device_fs()

    if operation == &#34;get&#34;:
        src_check = self.check_device_file
        src_device_fs = device_fs
        dst_check = self.check_local_file
    elif operation == &#34;put&#34;:
        src_check = self.check_local_file
        dst_check = self.check_device_file
        dst_device_fs = device_fs
    else:
        raise ValueError(f&#34;Operation &#39;{operation}&#39; is not supported&#34;)

    if verify:
        # gather info on source side
        src_file_data = await src_check(src_device_fs, src)
        self.logger.debug(f&#34;Source file &#39;{src}&#39;: {src_file_data}&#34;)
        if not src_file_data.hash:
            # source file cannot be found, we are done here
            self.logger.warning(f&#34;Source file &#39;{src}&#39; does NOT exists!&#34;)
            return result
        # gather info on destination file
        dst_file_data = await dst_check(dst_device_fs, dst)
        self.logger.debug(f&#34;Destination file &#39;{dst}&#39;: {dst_file_data}&#34;)
        # check if destination file exists
        if dst_file_data.hash:
            result.exists = True
        # check if destination file has the same hash as source
        if dst_file_data.hash and src_file_data.hash == dst_file_data.hash:
            result.verified = True
            # no need to transfer file
            self.logger.info(f&#34;&#39;{dst}&#39; file already exists at destination and verified OK&#34;)
            return result

        # if hash does not match and we want to overwrite
        if dst_file_data.hash and not overwrite:
            self.logger.warning(f&#34;&#39;{dst}&#39; file will NOT be overwritten!&#34;)
            return result

        # check if we have enough free space to transfer the file
        if dst_file_data.free &lt; src_file_data.size:
            self.logger.warning(
                f&#34;&#39;{dst}&#39; file is too big ({src_file_data.size}). Destination free space: &#34;
                f&#34;{dst_file_data.free}&#34;
            )
            return result

    # check if we are capable of transferring files
    scp_capability = await self._ensure_scp_capability(force=force_scp_config)
    if scp_capability is False:
        self.logger.error(&#34;SCP feature is not enabled on device!&#34;)
        return result

    _need_to_cleanup = scp_capability

    # transfer the file
    try:
        _transferred = await self._async_file_transfer(
            operation,
            src,
            dst,
            progress_handler=progress_handler,
            prevent_timeout=prevent_timeout,
        )
        result.transferred = _transferred
    except Exception as e:
        raise e

    # clean up if needed
    if cleanup and _need_to_cleanup:
        await self._cleanup_after_transfer()

    if verify:
        # check destination file after copy
        dst_file_data = await dst_check(dst_device_fs, dst)
        # check if file was created
        if dst_file_data.hash:
            result.exists = True
        # check if file has the same hash as source
        if dst_file_data.hash and dst_file_data.hash == src_file_data.hash:
            result.verified = True
        else:
            self.logger.warning(f&#34;&#39;{dst}&#39; failed hash verification!&#34;)
    else:
        # assuming transfer created the file even if we did not check hash
        if result.transferred:
            result.exists = True
    return result</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scrapli_community.features.asyncscp.FileCheckResult"><code class="flex name class">
<span>class <span class="ident">FileCheckResult</span></span>
<span>(</span><span>hash: str, size: int, free: int)</span>
</code></dt>
<dd>
<div class="desc"><p>hash - hash value string (empty on error)</p>
<p>size - size in bytes</p>
<p>free - free space in bytes (0 on error)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FileCheckResult:
    &#34;&#34;&#34;
    hash - hash value string (empty on error)

    size - size in bytes

    free - free space in bytes (0 on error)
    &#34;&#34;&#34;

    hash: str
    size: int
    free: int</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="scrapli_community.features.asyncscp.FileCheckResult.free"><code class="name">var <span class="ident">free</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli_community.features.asyncscp.FileCheckResult.hash"><code class="name">var <span class="ident">hash</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli_community.features.asyncscp.FileCheckResult.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scrapli_community.features" href="../index.html">scrapli_community.features</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="scrapli_community.features.asyncscp.driver" href="driver.html">scrapli_community.features.asyncscp.driver</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scrapli_community.features.asyncscp.AsyncSCPFeature" href="#scrapli_community.features.asyncscp.AsyncSCPFeature">AsyncSCPFeature</a></code></h4>
<ul class="">
<li><code><a title="scrapli_community.features.asyncscp.AsyncSCPFeature.check_device_file" href="#scrapli_community.features.asyncscp.AsyncSCPFeature.check_device_file">check_device_file</a></code></li>
<li><code><a title="scrapli_community.features.asyncscp.AsyncSCPFeature.check_local_file" href="#scrapli_community.features.asyncscp.AsyncSCPFeature.check_local_file">check_local_file</a></code></li>
<li><code><a title="scrapli_community.features.asyncscp.AsyncSCPFeature.file_transfer" href="#scrapli_community.features.asyncscp.AsyncSCPFeature.file_transfer">file_transfer</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrapli_community.features.asyncscp.FileCheckResult" href="#scrapli_community.features.asyncscp.FileCheckResult">FileCheckResult</a></code></h4>
<ul class="">
<li><code><a title="scrapli_community.features.asyncscp.FileCheckResult.free" href="#scrapli_community.features.asyncscp.FileCheckResult.free">free</a></code></li>
<li><code><a title="scrapli_community.features.asyncscp.FileCheckResult.hash" href="#scrapli_community.features.asyncscp.FileCheckResult.hash">hash</a></code></li>
<li><code><a title="scrapli_community.features.asyncscp.FileCheckResult.size" href="#scrapli_community.features.asyncscp.FileCheckResult.size">size</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>